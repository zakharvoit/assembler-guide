\documentclass[a4paper,12pt]{article}
\usepackage{fullpage}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{hyperref}

\begin{document}

\lstset{language=[x86masm]Assembler}
\lstset{frame=single}

\section{Регистры}

В качестве глобальных переменных служат регистры.
Регистры общего назначения (которые можно использовать в своих
вычислениях):

Регистры для вычислений:
\begin{itemize}
  \item rax -- accumulator регистр
  \item rbx -- base регистр
  \item rcx -- counter регистр
  \item rdx -- data регистр 
  \item r8-r15 -- регистры, которым поленились дать имена (появились
    только в x86\_64)
\end{itemize}

Никакого особого смысла их названия не несут, хотя rax обычно
используется для возврата значения из функции, а rcx -- в качестве
счетчика циклов.

Все эти регистры имеют разрядность 64 бита, но из регистров rax, rbx,
rcx и rdx можно вытаскивать и младшие биты, например:

\begin{itemize}
  \item rax -- 64 битный регистр
  \item eax -- 32 битный регистр (младшие 32 бита rax)
  \item ax -- 16 битный регистр (младшие 16 битов eax)
  \item al -- 8 битный регистр (младшие 8 бит ax)
  \item ah -- 8 битный регистр (старшие 8 бит ax)
\end{itemize}

Такая же табличка верна для rbx, rcx и rdx.

Регистры ``индексов'':
\begin{itemize}
  \item rsi -- source index регистр
  \item rdi -- destination index регистр
\end{itemize}

Эти регистры можно использовать как и прежние, но чаще их используют в
качестве указателей на данные. Также, как можно догадаться из
названия, rsi чаще используют для данных, из которых читают, а rdi - для данных,
в которые пишут.

Также есть регистр rsp, он указывает на вершину стека, нам он
понадобится позже для объявления локальных массивов.

Есть регистр rbp, он тоже имеет особое значение, но нам оно скорее
всего не понадобится.

Также есть флаги сравнений, с ними мы познакомимся позже.

\section{Процедуры}

Процедура в ассемблере - это просто метка. Метка - это такая штука,
которая при загрузке программы становится просто адресом, указывающим
на какую-то инструкцию.

Есть специальный регистр rip, который указывает на адрес текущей
команды. На каждом такте процессор выполняет команду по этому адресу и
увеличивает его.

Например объявим процедуру foo, которая умножает rax на два:

\lstinputlisting{proceduresexample.s}

Команда ret берет с вершины стека адрес, откуда была вызвана функция и
присваеивает его регистру rip (передает выполнение на следущую команду
после вызова).

Теперь в другом месте программы мы можем вызвать эту фунцию:

call foo            

Команда call присваивает регистру rip адрес, на который указывает
метка foo. Значит на следущем такте выполнится первая инструкция после
метки foo.

Если мы хотим передать аргументы в функцию есть два способа:

\begin{enumerate}
  \item Положить аргументы в стек.

    \lstinputlisting{stackargs.s}
      
  \item Передать аргументы в качестве регистров (именно этот способ
    нам подойдет, потому что аргументов будет немного и так проще).

    \lstinputlisting{regargs.s}
          
    При использовании этого способа лучше записывать какие именно
    регистры для чего используются (как в примере), чтобы чего-нибудь
    не перепутать.

\end{enumerate}

Если мы хотим использовать какие-то регистры для вычислений, то нужно
их сохранить в стеке, а после вернуть им первоначальные значения,
чтобы не помешать замыслам вызывающей функции относительно этих
регистров.

Для пример напишем функцию, которая меняет местами содержимое двух
регистров:

\lstinputlisting{swap.s}

При старте программы запускается процедура с меткой \_start.

Также в процедурах можно создавать локальные метки, они должны
начинаться с символа ``.'' такие метки локальны для каждой функции (на
самом деле их реальное название получается конкатенацией названия
метки без точки и метки с точкой, но в коде можно писать просто
название с точкой).

\section{Условия и циклы}

Как сравнить два числа?

Для этого используется команда cmp и команды условных переходов.
Давайте напишем функцию, которая вычисляет максимум из двух чисел.

\lstinputlisting{max.s}

Также для условных переходов можно использовать следущие команды:
\begin{itemize}
  \item je -- Jump if Equal
  \item jne -- Jump if Not Equal
  \item jl -- Jump if Less (for signed numbers)
  \item jle -- Jump if Less or Equal (for signed numbers)
  \item jg -- Jump if Great (for signed numbers)
  \item jge -- Jump if Great or Equal (for signed numbers)
  \item jb -- Jump if Below (less) (for unsigned numbers)
  \item jbe -- Jump if Below or Equal (for unsigned numbers)
  \item ja -- Jump if Above (great) (for unsigned numbers)
  \item jae -- Jump if Above or Equal (for unsigned numbers)
\end{itemize}

Для примера цикла напишем функцию, вычисляющую $ \sum\limits_{i=0}^n i $:

\lstinputlisting{sum.s}

\section{Массивы}

Массивы проще всего заводить на стеке. Стек хранится задом наперед,
значит, если мы прибавим к rsp n, то сможем пользоваться n байтами
между rsp и rsp + n - 1 для наших нужд.

Для индексации нужно использовать какой-нибудь регистр в качестве
указателя (он будет хранить адрес начала нашего массива).

Сразу напишем пример кода, который заполняет массив последовательными
числами:

\lstinputlisting{array.s}

\section{Разрядность операции}

Большинство операций поддерживают работу не только с 64 битными
регистрами.

Если мы напишем:

mov al, 8

Тогда содержимое ah, ax и тд. не повредится, то есть операция была 8
битной.

Исключение составляют операции push и pop, они могут принимать только
64 битный операнд.

То есть компилятор понимает разрядность операции по разрядности
операндов.

Также можно указать разрядность явно, для этого служат ключевые слова:

\begin{itemize}
  \item byte -- 8 бит
  \item word -- 16 бит
  \item dword -- 32 бит
  \item qword -- 64 бит
\end{itemize}

Например, команда:

mov qword [rsi], 0
 
Занулит байты [rsi, rsi + 8]. Если разрядность не прописать в такой
команде, то ничего не скомпилируется, так как по константе 0
определить разрядность невозможно.

\section{Системные функции}

Для вызова системных функций используется команда syscall,
обязательный аргумент у нее rax -- номер системной функции. Номера
функций для линукса и их аргументы можно погуглить. Для примера
напишем функцию, которая выводит строку на stdout:

\lstinputlisting{putstr.s}

\section{Синтаксис nasm}

С синтаксисом nasm можно познакомиться в файле \url{https://github.com/sorokin/cpp-year2013/blob/master/helloasm/hello.asm}.

\end{document}
